#+TITLE: Emacs Config
#+AUTHOR: Andrew Jacobson
#+STARTUP: indent

* Introduction

This is my Emacs config. There are many like it, but this one is mine.

* Personal Info

In case my emacs config gets lost.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Andrew Jacobson"
        user-mail-address "andrew.isaac.jacobson@gmail.com")
#+END_SRC

* Custom File

Load the auto-generated =custom.el= file from the dotemacs dir.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC

* Basic Configuration
** Require newline at EOF

#+BEGIN_SRC emacs-lisp
  (setq require-final-newline t)
  (setq require-trailing-newline t)
#+END_SRC

** Allow 'y' or 'n' answers

Typing 'yes' or 'no' is tedious.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Set backup directory

Set backup and auto-save-list directories.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+END_SRC

** Set UTF-8

UTF-8. UTF-8, everywhere.

#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system   'utf-8)
  (set-terminal-coding-system  'utf-8)
  (set-keyboard-coding-system  'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system        'utf-8)
#+END_SRC

** Remove cursor blink

The cursor blink annoys me. This makes it stop.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

** Tabs

Prevent tab indentation and set default tab-width.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
  (setq-default tab-width 2)
  (setq-default indicate-empty-lines t)
#+END_SRC

** Show matching parens

Highlight opening/closing paren when cursor is on/after opening/closing paren respectively.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
#+END_SRC

** Delete region when typing

This allows me to type over a selected region, which is nice.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode t)
#+END_SRC

** No bell

Turn off audible and visible bell since it is annoying.

#+BEGIN_SRC emacs-lisp
  (setq visible-bell nil)
  (setq ring-bell-function 'ignore)
#+END_SRC

** Show column info

#+BEGIN_SRC emacs-lisp
  (column-number-mode t)
#+END_SRC

** Display line numbers

Turn on linum mode globally.

#+BEGIN_SRC emacs-lisp
  (global-linum-mode)
  (diminish 'linum-mode)
#+END_SRC

** Use line wrapping

#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode)
  (diminish 'visual-line-mode)
#+END_SRC

** Highlight current line

Highlight the line that the cursor is currently on.

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

** Delete trailing white space on save

Clean up superfluous white space in buffer on save.

#+BEGIN_SRC emacs-lisp
  (add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

** Make it easy to edit this file

Setup some functions/keybindings to enable quick editing/reloading
of this file.

#+BEGIN_SRC emacs-lisp
  (defun aj/find-config ()
    "Edit ~/.emacs.d/config.org"
    (interactive)
    (find-file
     (concat user-emacs-directory "config.org")))

  ;; make room for config command prefix
  (bind-key "C-c c"    nil)
  (bind-key "C-c c e" 'aj/find-config)
#+END_SRC

** Load path

Setup =load-path=.

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/misc/")
#+END_SRC

** Remove annoying UI

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+END_SRC

* Mac

Stuff for Mac OS.

#+BEGIN_SRC emacs-lisp
  (when (string-equal system-type 'darwin)
    ;; Make sure alt and meta are setup
    (setq mac-option-modifier 'alt)
    (setq mac-command-modifier 'meta)

    ;; Avoid sending meta keystrokes to the os
    (setq mac-pass-command-to-system nil)

    ;; Quiet `ls does not support --dired' error
    (setq dired-use-ls-dired nil)

    ;; Fullscreen
    (setq ns-use-native-fullscreen nil))
#+END_SRC

* Global Keybindings

Some globally useful keybindings.

#+BEGIN_SRC emacs-lisp
  ;; allow C-j to be used in place of C-x
  (define-key key-translation-map "\C-j" "\C-x")

  ;; make room for user prefix
  (bind-key "M-j"     nil)
  (bind-key "C-S-y"   'kill-ring-search)
  (bind-key "C-S-j"   (lambda () (interactive) (join-line -1)))
  (bind-key "C-S-SPC" 'exchange-point-and-mark)
  (bind-key "C-x C-/" 'comment-region)
  (bind-key "C-x C-;" 'uncomment-region)
  (bind-key "C-x C-d" 'dired-jump)
  (bind-key "M-/"     'hippie-expand)
#+END_SRC

* Look & Feel
** Packages
*** rainbow-mode

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-mode
    :diminish
    :ensure t)
#+END_SRC

** Font
*** Tell emacs to use [[http://adobe-fonts.github.io/source-code-pro/][Source Code Pro]] as default font

This is a good font that I am using for now.
Should maybe try out some other fonts too...

#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font . "Source Code Pro-14"))
#+END_SRC

*** Enable emojis :)

#+BEGIN_SRC emacs-lisp
  (let ((font (if (= emacs-major-version 25)
                  "Symbola"
                (cond ((string-equal system-type "darwin") "Apple Color Emoji")
                      ((string-equal system-type "gnu/linux") "Symbola")))))
    (set-fontset-font t 'unicode font nil 'prepend))
#+END_SRC

** Theme

#+BEGIN_SRC emacs-lisp
  (use-package color-theme-sanityinc-tomorrow
    :ensure t
    :config (load-theme 'sanityinc-tomorrow-night t))
#+END_SRC

* Editing & Movement
** Packages
*** [[https://github.com/magnars/expand-region.el][expand-region]]

Neat package that allows you to expand your selection area
by dynamic semantic units.

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind (("C-=" . 'er/expand-region)))
#+END_SRC

*** [[https://github.com/magnars/multiple-cursors.el][multiple-cursors]]

Does just what it says: gives you multiple cursors in a buffer.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :bind (("C-S-m" . mc/mark-all-like-this-dwim)
           ("C-+"   . mc/mark-next-like-this)
           ("C-_"   . mc/unmark-next-like-this)))
#+END_SRC

*** [[https://github.com/wyuenho/move-dup][move-dup]]

Handy little package I like, which allows me to move selections
up and down in a buffer as well as duplicate selections.

#+BEGIN_SRC emacs-lisp
  (use-package move-dup
    :ensure t
    :bind (("C-S-p" . md/move-lines-up)
           ("C-S-n" . md/move-lines-down)
           ("M-P"   . md/duplicate-up)
           ("M-N"   . md/duplicate-down)))
#+END_SRC

*** [[https://github.com/re5et/smart-indent-rigidly][smart-indent-rigidly]]

Manually indent/unindent lines at will.

#+BEGIN_SRC emacs-lisp
  (use-package smart-indent-rigidly
    :ensure t
    :bind (("C-<tab>"   . smart-rigid-indent)
           ("<backtab>" . smart-rigid-unindent)))
#+END_SRC

** Functions
*** Indent and open newline

#+BEGIN_SRC emacs-lisp
  (defun indent-and-open-newline (&optional previous)
    "Add a newline after current line and tab to indentation.
    If PREVIOUS is non-nil, go up a line first."
    (interactive)
    (if previous
        (previous-line))
    (end-of-line)
    (newline)
    (indent-for-tab-command))
#+END_SRC

*** Previous indent and open newline

#+BEGIN_SRC emacs-lisp
  (defun previous-indent-and-open-newline ()
    "Call indent-and-open-newline with non-nil PREVIOUS value"
    (interactive)
    (indent-and-open-newline t))
#+END_SRC

*** Indent whole damn buffer

Wouldn't be caught dead without this one.

#+BEGIN_SRC emacs-lisp
  (defun indent-buffer ()
    "Fix indentation on the entire buffer."
    (interactive)
    (save-excursion
      (indent-region (point-min) (point-max))))
#+END_SRC

** Keybindings

#+BEGIN_SRC emacs-lisp
  (bind-key "M-o" 'indent-and-open-newline)
  (bind-key "C-o" 'previous-indent-and-open-newline)
  (bind-key "C-," 'indent-buffer)
  (bind-key "M-z" 'zap-up-to-char)
  (bind-key "M-F" 'forward-to-word)
  (bind-key "M-B" 'backward-to-word)
#+END_SRC

* Spelling
** Hooks

#+BEGIN_SRC emacs-lisp
  (defadvice org-mode-flyspell-verify (after org-mode-flyspell-verify-hack activate)
    (let* ((rlt ad-return-value)
           (begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
           (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
           (case-fold-search t)
           b e)
      (when ad-return-value
        (save-excursion
          (setq b (re-search-backward begin-regexp nil t))
          (if b (setq e (re-search-forward end-regexp nil t))))
        (if (and b e (< (point) e)) (setq rlt nil)))
      (setq ad-return-value rlt)))

  (defun aj/org-ispell ()
    "Configure `ispell-skip-region-alist' for `org-mode'."
    ;; (make-local-variable 'ispell-skip-region-alist)
    (setq ispell-parser 'tex)
    (add-to-list 'ispell-skip-region-alist '(org-property-drawer-re))
    (add-to-list 'ispell-skip-region-alist '("~" "~"))
    (add-to-list 'ispell-skip-region-alist '("=" "="))
    (add-to-list 'ispell-skip-region-alist '("^#\\+BEGIN_SRC" . "^#\\+END_SRC")))

  (add-hook 'org-mode-hook #'aj/org-ispell)

  (add-hook 'message-mode-hook  'flyspell-mode)
  (add-hook 'org-mode-hook      'flyspell-mode)
  (add-hook 'text-mode-hook     'flyspell-mode)
  (add-hook 'flyspell-mode-hook '(lambda () (diminish 'flyspell-mode "SP")))
#+END_SRC

** Keybindings

#+BEGIN_SRC emacs-lisp
  ;; Make room for ispell prefix
  (bind-key "C-c i"    nil)
  (bind-key "C-c i b" 'ispell)
  (bind-key "C-c i w" 'ispell-word)

  (eval-after-load "flyspell"
    '(define-key flyspell-mode-map (kbd "C-,") nil))
#+END_SRC

* Frames, Windows & Buffers
** Functions
*** Next frame in window

Helper function that moves to the next window of the current frame.
Essentially a simplified version of =other-window= (C-x o).

#+BEGIN_SRC emacs-lisp
  (defun next-frame-in-window ()
    "Jump to next window in current frame"
    (interactive)
    (select-window (next-window)))
#+END_SRC

*** Previous frame in window

Helper function that moves to the previous window of the current frame.

#+BEGIN_SRC emacs-lisp
  (defun previous-frame-in-window ()
    "Jump to previous window in current frame"
    (interactive)
    (select-window (previous-window)))
#+END_SRC

*** Rotate windows in frame

Helper function that rotates the windows of the current frame in a
counter-clockwise direction.

#+BEGIN_SRC emacs-lisp
  (defun rotate-windows-in-frame ()
    (interactive)
    (let ((map
           (mapcar
            (lambda (window)
              `(,window
                ,(window-buffer
                  (next-window window))))
            (window-list))))
      (mapcar
       (lambda (window-to-buffer)
         (let ((window (car window-to-buffer))
               (buffer (cadr window-to-buffer)))
           (select-window window)
           (switch-to-buffer buffer))) map)))
#+END_SRC

*** Kill focused buffer

Helper function that kills the currently focused buffer. Pretty self explanatory.

#+BEGIN_SRC emacs-lisp
  (defun kill-focused-buffer ()
    (interactive)
    (kill-buffer (current-buffer)))
#+END_SRC

** Keybindings

#+BEGIN_SRC emacs-lisp
  (bind-key "<M-return>" 'toggle-frame-fullscreen)
  (bind-key "C-S-b"      'bury-buffer)
  (bind-key "C-S-f"      'unbury-buffer)
  (bind-key "C-x C-b"    'ibuffer)
  (bind-key "M-j l"      'next-frame-in-window)
  (bind-key "M-j h"      'previous-frame-in-window)
  (bind-key "C-|"        'rotate-windows-in-frame)
  (bind-key "C-x C-k"    'kill-focused-buffer)
#+END_SRC

* Dired
** Packages
*** [[https://github.com/juan-leon/dired-efap][dired-efap]]

dired-efap allows me to edit a file name in place while in a dired buffer.

#+BEGIN_SRC emacs-lisp
  (use-package dired-efap
    :ensure t
    :config (setq dired-efap-initial-filename-selection nil))
#+END_SRC

*** dired-details

#+BEGIN_SRC emacs-lisp
  (require 'dired-details)
  (setq-default dired-details-hidden-string "--- ")
  (dired-details-install)
#+END_SRC

** Hooks

Setup dired-mode-hook.

#+BEGIN_SRC emacs-lisp
  (defun aj/dired-mode-hook ()
    "Setup dired-mode-hook"
    (define-key dired-mode-map (kbd "<backspace>") 'dired-up-directory)
    (define-key dired-mode-map (kbd "e") 'dired-efap))

  (add-hook 'dired-mode-hook 'aj/dired-mode-hook)
#+END_SRC

* Discoverability
** Packages
*** [[https://github.com/abo-abo/swiper][ivy]]

Install and setup ivy/swiper/counsel for discoverability completion.

#+BEGIN_SRC emacs-lisp
  (defun aj/config--ivy ()
    "Do configuration for ivy-mode."
    (ivy-mode 1)
    ;; Add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
    (setq ivy-use-virtual-buffers t)
    ;; Number of result lines to display
    (setq ivy-height 15)
    ;; Does not count candidates
    (setq ivy-count-format "")
    ;; No regexp by default
    (setq ivy-initial-inputs-alist nil)
    ;; Configure regexp engine.
    (setq ivy-re-builders-alist
          ;; Allow input not in order
          '((t . ivy--regex-ignore-order))))

  (defun aj/init--counsel ()
    "Do configuration for counsel mode."
    (setq counsel-yank-pop-height 15))

  (use-package swiper
    :ensure t)

  (use-package counsel
    :ensure t
    :bind (("M-x"     . counsel-M-x)
           ("C-x C-f" . counsel-find-file)
           ("M-y"     . counsel-yank-pop))
    :init (aj/init--counsel))

  (use-package ivy
    :ensure t
    :after (counsel swiper)
    :diminish
    :bind (("C-s" . swiper)
           ("C-r" . swiper)
           :map ivy-minibuffer-map
           ("M-y" . ivy-next-line))
    :config (aj/config--ivy))

  (bind-key "C-c s"   nil)
  (bind-key "C-c s g" 'counsel-git)
  (bind-key "C-c s j" 'counsel-git-grep)
  (bind-key "C-c s a" 'counsel-ag)
  (bind-key "C-c s l" 'counsel-locate)
#+END_SRC

*** [[https://github.com/justbur/emacs-which-key][which-key]]

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :ensure t
    :diminish
    :config (which-key-mode))
#+END_SRC

* Completion
** Packages
*** [[http://company-mode.github.io/][company-mode]]

Install and enable [[http://company-mode.github.io/][company-mode]] globally.

#+BEGIN_SRC emacs-lisp
  (defun aj/config--company ()
    "Do configuration for company-mode."
    (setq company-tooltip-align-annotations t)
    (global-company-mode))

  (use-package company
    :ensure t
    :diminish
    :bind (("C-c <tab>" . company-complete))
    :config (aj/config--company))
#+END_SRC

* Programming
** General
*** Packages
**** [[https://github.com/purcell/exec-path-from-shell][exec-path-from-shell]]

Sync Emacs env with shell env. Especially important on OSX.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :init (exec-path-from-shell-initialize))
#+END_SRC

**** [[https://magit.vc/][magit]]

Magit is an amazing git porcelain! Let's install it and set it up.

#+BEGIN_SRC emacs-lisp
  (defun aj/config--magit ()
    "Do magit configuration."
    (setq magit-completing-read          'ivy-completing-read)
    (setq magit-completing-read-function 'ivy-completing-read))

  (use-package magit
    :ensure t
    :config (aj/config--magit)
    :bind (("M-j g" . magit-status)))
#+END_SRC

**** [[https://github.com/tsdh/highlight-parentheses.el][highlight-parentheses]]

Gives nice highlighting for parens that your cursor is currently inside of.

#+BEGIN_SRC emacs-lisp
  (use-package highlight-parentheses
    :ensure t
    :diminish
    :init (add-hook 'prog-mode-hook #'highlight-parentheses-mode))
#+END_SRC

**** [[https://github.com/Fuco1/smartparens][smartparens]]

Install and setup smartparens to behave similarly to paredit.

#+BEGIN_SRC emacs-lisp
  (defun aj/config--smartparens ()
    "Do configuration for smartparens."
    ;; Pull in default smartparens config
    (use-package smartparens-config)
    ;; Make `sp-kill-hybrid-sexp' delete all whitespace up until next sexp
    (setq sp-hybrid-kill-excessive-whitespace t))

  (use-package smartparens
    :ensure t
    :diminish
    :config (aj/config--smartparens)
    :bind (("C-M-a" . sp-beginning-of-sexp)
           ("C-M-e" . sp-end-of-sexp)
           ("C-M-p" . sp-up-sexp)
           ("C-M-n" . sp-down-sexp)
           ("C-M-f" . sp-forward-sexp)
           ("C-M-b" . sp-backward-sexp)
           ("M-s"   . sp-splice-sexp)
           ("C-)"   . sp-forward-slurp-sexp)
           ("C-}"   . sp-forward-barf-sexp)
           ("C-("   . sp-backward-slurp-sexp)
           ("C-{"   . sp-backward-barf-sexp))
    :init (smartparens-global-strict-mode t))
#+END_SRC

**** [[https://github.com/bbatsov/projectile][projectile]]

Install and setup projectile for project management.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :custom (projectile-completion-system 'ivy "Use ivy for projectile completion")
    :hook (prog-mode . projectile-mode))
#+END_SRC

**** [[https://github.com/ericdanan/counsel-projectile][counsel-projectile]]

Hook projectile up to counsel for consistent discoverability.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :config (counsel-projectile-mode))
#+END_SRC

**** [[https://github.com/mhayashi1120/Emacs-wgrep][wgrep]]

#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    :config (setq wgrep-auto-save-buffer t))

  (use-package wgrep-ag
    :ensure t)
#+END_SRC

** Languages
*** JavaScript
**** Packages
***** [[https://github.com/mooz/js2-mode][js2-mode]]

js2-mode is an improved major mode for editing JavaScript. Let's install and configure it.

#+BEGIN_SRC emacs-lisp
  (defun aj/config--js2 ()
    "Do configuration for js2-mode."
    (setq js2-basic-offset 2)
    (setq js2-mode-indent-ignore-first-tab t)
    (setq js2-highlight-external-variables nil)
    (setq js2-highlight-level 3)
    (setq js2-mirror-mode nil)
    (setq js2-mode-show-parse-errors t)
    (setq js2-mode-show-strict-warnings t)
    (setq js2-pretty-multiline-declarations t)
    (setq js2-bounce-indent-p nil))

  (use-package js2-mode
    :ensure t
    :mode ("\\.js\\'" . js2-mode)
    :init (add-hook 'js2-hook 'aj/config--js2))
#+END_SRC

***** [[https://github.com/magnars/js2-refactor.el][js2-refactor]]

#+BEGIN_SRC emacs-lisp
  (defun aj/config--js2-refactor ()
    "Do configuration for js2-refactor."
    (js2r-add-keybindings-with-prefix "C-c C-r"))

  (use-package js2-refactor
    :ensure t
    :diminish js2-refactor-mode
    :config (aj/config--js2-refactor)
    :init (add-hook 'js2-mode-hook #'js2-refactor-mode))
#+END_SRC

***** [[https://github.com/nicolaspetton/xref-js2][xref-js2]]

#+BEGIN_SRC emacs-lisp
  (use-package xref-js2
    :ensure t
    :config (define-key js-mode-map (kbd "M-.") nil))

  (add-hook
   'js2-mode-hook
   (lambda ()
     (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
#+END_SRC

***** [[https://github.com/proofit404/company-tern][company-tern]]

#+BEGIN_SRC emacs-lisp
  (defun aj/config--tern ()
    "Do configuration for tern mode."
    (add-to-list 'company-backends 'company-tern)
    (define-key tern-mode-keymap (kbd "M-.") nil)
    (define-key tern-mode-keymap (kbd "M-,") nil)
    (define-key tern-mode-keymap (kbd "C-c C-r") nil))

  (use-package company-tern
    :ensure t
    :diminish tern-mode
    :config (aj/config--tern))

  (add-hook 'js2-mode-hook #'tern-mode)
#+END_SRC

*** TypeScript

Do setup for =typescript-mode= and =tide=.

#+BEGIN_SRC emacs-lisp
  (defun aj/setup-tide ()
    "Setup TIDE."
    (tide-setup)
    (flycheck-mode +1)
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    (tide-hl-identifier-mode +1)
    (eldoc-mode +1))

  (defun aj/setup-typescript ()
    "Setup TypeScript environment."
    (interactive)
    (setq typescript-expr-indent-offset 2)
    (aj/setup-tide))

  (use-package typescript-mode
    :ensure t
    :mode (("\\.ts\\'" . typescript-mode))
    :init
    (use-package tide
      :ensure t
      :diminish
      :hook (typescript-mode . aj/setup-typescript)))
#+END_SRC

* TODOS
** TODO Move global keybindings to their own respective sections
